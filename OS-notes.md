# Notes in OS from an edx course




## Interrupts
http://faculty.salina.k-state.edu/tim/ossg/Introduction/OSworking.html
- An operating system is **interrupt-driven**.
- Signals sent to the CPU by external devices, normally I/O devices.
- Tells the CPU to stop its current activities and execute the appropriate part of the operating system.
- Interrupt architecture must save the address of the interrupted instruction.
- Hardware may trigger an interrupt at any time by sending a signal to the CPU, usually by way of the system bus.
- When the CPU is interrupted, it stops what it is doing and immediately transfers execution to a fixed location - this location usually contains the starting address where the service routine for the interrupt is located. The interrupt service routine executes; on completion, the CPU resumes the interrupted computation.
- The interrupt must transfer control to the appropriate interrupt service routine. The straightforward method for managing this transfer would be:
1. Invoke a generic routine to examine the interrupt information.
2. The routine, in turn, would call the interrupt-specific handler.
However, interrupts must be handled quickly, as they occur very frequently. A table of pointers to interrupt routines can be used instead to provide the necessary speed. The interrupt routine is called indirectly through the table, with no intermediate routine needed.
- Generally, the table of pointers is stored in low memory (the first hundred or so locations). These locations hold the addresses of the interrupt service routines for the various devices.
- This array is called the **interrupt vector**.
- This is indexed by a unique number, given with the interrupt request, to provide the address of the interrupt service routine for the interrupting device.
- The interrupt architecture must also save the state information of whatever was interrupted, so that it can restore this information after servicing the interrupt.
- If the interrupt routine needs ot modify the processr state - like modifying register values - it must explicitly save the current state and then restore that state before returning.
- After the interrupt is serviced, the saved return address is loaded into the program counter, and the interrupted computation resumes as though the interrupt had not occured.

### System interrupt table/Interrupt Descrpitor Table
- A data structure used by the x86 architecture to implement an **interrupt vector table**.
- Used by the processor to determine the correct response to interrupts and exceptions.
- Triggered by three types of events:
  - Hardware interrupts
  - Software interrupts
  - Processor exceptions, also known as Traps

### Implementation/Interrupt Handling
- Device asserts interrupt line.
- CPU finishes the current instruction before checking for interrupts.
- CPU detects that an interrupt is being called, and obtains the IRQ (Interrupt Request) number from the PIC (see Programmable Interrupt Controller).
- Switch to kernel stack if necessary, switch privilege level if needed.
- Save the state of the interrupted basic program to specific registers: `SS`, `ESP`, `EFLAGS`, `CS`, `EIP`, error code. The state can be restored by the `iret` instruction.
- Suspend the current task
- Jump to the interrupt handler, which is split into a top half at OS level. It does the following:
  - Respond to the interrupt
  - More storing of the program state
  - Schedule the bottom half of the interrupt handler
  - `IRET` returns from the interrupt
- Restore flags and registers saved earlier, using it to restore the interrupted task.
- The bottom half of the interrupt, is the work horse for the interrupt.

- CPU hardware has a line/wire called the **interrupt-request line** that the cpu senses after executing every instruction.
- When the CPU detects that a controller has asserted a signal on the line, it saves the current state of the CPU by storing the registers and the program counter to memory.
- It then reads the interrupt number and jumps to the interrupt-handler routine by using that number as an index to the interrupt vector.
- It starts execution at the address associated with that index.

### Interrupt request lines
- Nonmaskable interrupt, reserved for events such as unrecoverable memory errors
- Maskable interrupt, can be turned off by the CPU before the execution of critical instruction sequences that must not be interrupted. This is used by device controllers to request service.

### Interrupt chaining
- Each element in the interrupt vector points to the head of a list of interrupt handlers.
- When an interrupt is raised, the handlers on the corresponding list are called one by one, until one is ofund that can service the request.

### Interrupt Priority levels

### Types of Interrupts
- **Hardware Interrupts** are generated by hardware devices to signal that they need some attention from the OS.
  - This can be Keystrokes on a keyboard, data sent/received from the network interface
  - Or the completion of a task which the OS requested earlier, such as transferring data between the hard drive and memory.
- **Software Interrupts** are generated by programs when they want to request a *system call* to be performed by the operating system.
- **Traps** are generated by the CPU itself to indicate that some error or condition occured for which assistance from the operating system is needed.

## Traps

## Exceptions

Interrupts are important because they give the user better control over the computer. Without interrupts, a user may have to wait for a given application to have a higher priority over the CPU to be ran. This ensures that the CPU will deal with the process immediately.

## User Operating System Interface
### Command Interpreter
- Some operating systems include the command interpreter in the kerneel
- Others, like Windows XP and UNIX treat the interpreter as a special program
- Systems with multiple command interpreters to choose from, they are called shells. E.g:
  - Bourne Shell
  - Bourne Again Shell (BASH)
  - C shell
  - Korn shell

## Device Controllers
- A controller is a chip, an expansion card, or a standalone device that interfaces with a peripheral device.
Some examples of device controllers are:
- **Memory Controller**: manages access to memory
- **Programmable Interrupt Controller**: an IC that helps the CPU handle interrupt requests coming from multiple different sources like external I/O devices which may occur simultaneously
- **Northbridge**: also called a **host bridge** is one of two chips in the core logic chipset architecture on a PC motherboard.
  - Connected directly to the CPU via the **front-side bus** or FSB.
  - Responsible for the tasks that require the highest performance.
  - Handles communication between RAM and PCI express video cards and the Southbridge.
  - Also known as the **Memory Controller Hub**.
  - Is usually paired with a **Southbridge**.
- **Southbridge**: Typically implements the slower capabilities of the motherboard in a northbridge/southbridge chipset computer architecture.
  - Not directly connected ot the CPU, is tied to the northbridge, instead.
  - Handles all of a computer's I/O functions, such as:
    - USB
    - Audio
    - Serial
    - System BIOS
    - ISA Bus
    - Interrupt Controller
    - IDE Channels

## Application Programs
Word processors, spreadsheets, compilers, web browsers, etc.

## System Programs

## Boot Process
- The **bootstrap program** is loaded at power-up or reboot
- Initializes all aspects of the system
- Loads the operating system kernel and starts execution

## Bootstrap Program
Stored in ROM or EEPROM (otherwise known as firmware)
Loads at power-up or reboot.
It is stored in ROM or EEPROM.
It initiializes all aspects of the system, loads the OS kernel and starts execution.

## Kernel
This is the one program that is running at all times on the computer.

## Device Communication
- Internal communications in a machine is done via a "bus"
 A bus is a physical pathway for communication between two or more devices
- The **System bus** is the main pathway between the CPU and main memory, but also carries data to and from Input and Output (IO) devices.
- **Universal Serial Bus** is the method of communication from the core of the system to external devices.
- **System Bus** is the main communication between the CPU and Main Memory. This has to be as fast as it can be.

## The CPU
- Small memory banks in the CPU called registers with virtually zero latency
- It may have a cache memory to perform more quickly
- Can only understand very basic commands and not the abstract concepts of condition or loop statements. Some of these commands are:
  - Move
  - Add
  - Subtract
  - Multiply
  - Compare
  - Jump
  to name a few.

## Registers

## Fetch-Execute Cycle
The CPU operates on a "fetch-decode-execute" cycle
  1. Fetch an instruction from Main Memory, and store it into an instruction register.
  2. Decode the instruction, moving any additional data that might be necessary.
  3. Execute the instruction.
  4. Go back to 1.
- Runs on an intrenal clock that goes as fast as the "Clock Speed" on processors.
- 16-bit machines use:
  - Operation Codes (also known as Opcodes) are 6 bits. These define the operations that the CPU must carry out.
  - Operand Addresses are 10 bits. These contain parameters for the operation to execute on

## Processor instruction sets
CPU designers create a set of instructions that a CPU can perform.
Each instruction can be represented by a numeric value.
For Example:
	ADD is 0x00
	AND is 0x20
	CMP is 0x38
	INT is 0xCD
	JMP is 0xE9
- Note: x86 was named after an instruction set that had only 86 instructions for the 8086 processor.

## Memory Heirarchy
The faster the memory, the less of it is available, and the higher it is in the heirarchy.
1. Registers
2. Cache (L1)
3. Cache (L2)
4. DDR / Main Memory

## Random Access Memory
- It is named "Random Access" because any address in the memory can be accessed in the same amount of time.
- Each byte has an address
- RAM is volatile
- When running a program, all the instructions/data are brought into RAM and, one-by-one, puled into the CPU by the fetch and execute cycle.

## Secondary Storage
- Currently, there are two types of storage
  1. HDD
  2. SSD

- What is an operating system
- How do OS work
- A short history of OS
- Preemptive processing concepts
- Architecture of an OS
- Some modern operating systems

## Disk Formatting Process
### Low-level formatting
This marks the surface of the disks with markers indicating the start of a recording block (typically today called sector markers) and other information like block CRC to be uesd later, in normal operations, by the disk controller to read or write data. This is intended to be the permanent foundation of the disk, and is often completed at the factory.

### Partitioning
This divides a disk into one or more regions, writing data structures to the disk to indicate the beginning and end of the regions. This level of formatting often includes checking for defective tracks or defective sectors.
Formatting a disk for use by an operating system and its applications typically involves three different processes.
- Disk partitioning or disk slicing is the creation of one or more regions on secondary storage, so that each reqion can be managed separately.
- The partitioning scheme is stored in a partition table such as Master Boot Record (MBR) or GUID Partition Table (GPT).
- Partitions usually contain a file system directly which is accomplished by creating a file system (formatting) on the partition.

### High-level formatting
This creates the file system format within a disk partition or a logical volume. This formatting includes the data structures used by the OS to identify the logical drive or partition's contents. This may occur during operating system installation, or when adding a new disk.
**Disk and distributed file system** may specify an optional boot block, and/or various volume and directory information for the operating system.



## Layers of Interaction
1. User - The actual person using the computer
2. Application - The application that the user is interacting with
3. Operating System
4. Hardware

## The Kernel
- The core component of the operating system
- Responsible for managing system resources
- Assists applications with performing work

## Resource Management
- Resources are finite
  - Memory
  - CPU time

## Processes
- A program in a running state
- Loaded into main memory
- Scheduled
- Can access files
- Can access networking connections
- Has code

## The Windows NT Model
TODO: Look more into this


## Storage Structure
- General-purpose computers run most of their programs from rewritable memory, called main memory or RAM.
- Main memory is commonly implemented in a semiconductor technology called Dynamic Random-Access memory (DRAM).
- The first program to run on computer power-on is a bootstrap program, which then loads the operating system.
- This program is stored in Electrically erasable programmable read-only memory (EEPROM) and other forms of firmware. This type of storage is infrequently written to and is nonvolatile.
- Altohugh EEPROM is writable, it cannot be changed frequently due to its memory only having a limited amount of write cycles, but have an unlimited amount of read cycles.
- EEPROM is slow, and so it contains mostly static programs and data that aren't frequently used.
- For example, a smartphone uses the EEPROM to store serial numbers and hardware information about the device.
- Memory interaction is achieved through a sequence of `load` or `store` instructions to specific memory addresses.
- The `load` instruction moves a byte or word from main memory to an internal register within the CPU.
- The `store` instruction moves the contents of a register to main memory.

Since data cannot be stored in main memory because it is volatile, **secondary storage** is used as an extension of main memory.
This type of storage is able to hold large amounts of data permanently.
The most common secondary-storage devices are HDDs and Nonvolatile Memory (NVM) devices.
Many programs are stored in secondary storage until they are loaded into memory.

## I/O Structure
- There are two methods for handling I/O
  - After I/O starts, control returns to user program only upon I/O completion.
    - Wait instruction idles the CPU until the next interrupt.
    - Wait loop (contention for memory access)
    - At most, one I/O request is outstanding at a time, no simultaneous I/O processing.
  - After I/O starts, control returns to user program without waiting for I/O completion.
    - **System Call**: request to the OS to allow user to wait for I/O completion.
    - **Device-status table** contains entry for each I/O device indicating its type, address and state.
    - OS indexes into I/O device table to determine device status and to modify table entry to include interrupt.

## System Calls
A request from an application program for the operating system to perform some hardware action on behalf of the application. System calls are initiated with a software interrupt assemply language instruction. The argument to the interrupt instruction is a number, which corresponds to the index of an array in the OS kernel with pointers to the functions that provied the requested service. 

These provide and interface to the operating system services.

Application developers often do not have direct access to the system calls, but can access them through an application programming interface (API). The functions that are included in the API invoke the actual system calls. By using the API, certain benefits can be gained:
- Portability: as long as a system supports an API, any program using that API can compile and run.
- Ease of Use: Using the API can be signifiacntly easier than using the actual system call.

System Calls have 5 categories
- **Process Control**: Used to control processes
  - end and abort
  - load and execute
  - create and terminate process
  - get and set process attributes
  - wait for time
  - wait and signal event
  - allocate and free memory

- **File Manipulation**: Used to manipulate files
  - create and delete file
  - open and close
  - read, write and reposition
  - get and set file attributes

- **Device Management**: Managing/manipulating devices
  - request and release device
  - read and write, reposition
  - get and set device attributes
  - logially attach or detach device

- **Information Maintenance**: all info about our system must be maintained and updated
  - get and set date/time
  - get and set system data
  - get process, file or device attributes
  - set process, file or device attributes
  
- **Communications**: used for communication in between processes and devices
  - create and delete communication connection
  - send and receive messages
  - transefr status information
  - attach or detach remote devices

The standard C library provides the system-call interface for UNIX and Linux systems

## Linker
A liker combines several relocatable object modules into a single binary executable file. A loader loads the executable file into memory, where it becomes eligible to run on an available CPU.arch

## CPU Execution Mode
There are two modes of execution, known as **user mode** and **kernel or supervisor mode**.
User mode is restricted in that certain instructions cannot be executed, certain registers cannot be accessed, and I/O devices can not be accessed. A system call will set the CPU to kernel mode, as will traps and interrupts. Application programs cannot do this.

Mode bit: Supervisor or User mode
- Supervisor mode
  - can execute all machine instructions
  - can reference all memory locations
- User mode
  - can only execute a subset of instructions
  - can only reference a subset of memory 


## Process Control Block
A data structure for each process holding
- Register values
- Logical state
- Page map table mapping logical addresses to physical addresses
- Type and location of resources it holds
- List of resources it needs
- Parent process identification
- Security keys
- etc.

# Chapter 2
- OS Services
- User and OS Interface
- System Calls
- System Services
- Linkers and Loaders
- Why Applications are OS-specific
- Identify services provided by an operating system
- Illustrate how system calls are used to provide operating system services




## OS Services
- OS provides an environment for execution of programs and services to programs and users

One set of OS services provides functions that are helpul to:
- **Users**
  - User Interface
  - Program Execution
  - I/O Operations
  - FS manipulation
  - Communications
  - Error Detection

# UNIX
The original multi-user, multi-tasking OS designed to allow users to manage their own tasks
- Released into publict domain as open source software
- Many different flavors:
  - AIX
  - Linux
  - Solaris
  - etc...


=========================================
Stuff to get back to
- Traps
- CPU Execution Modes
  - Supervisor
  - User mode
- Process Control Block 
